Git Merge Issues

Let's imagine you made a bad merge. Starting from a clean state with no local changes, you made some code changes and committed them locally. Let "A" be the resulting commit. Then you did "git pull" at a time when "B" was the latest published commit, and there were conflicts. In the course of resolving conflicts and committing, you make a mistake and and up committing "C", but it is a bad merge; for example, it discards changes flowing from B. So the situation is:
    A ----   (local changes)
            \
             C (bad)
            /
       B --   (last published)

Then you push, and some time passes, so others push as well:
      A ----
            \
             C --- ... --- D (last published)
            /
       B --

Step by Step Guide to Solve this issue

Step 1: Re-merge the original commits

#Create a new merge node that is a correct merge of A and B
git checkout A - A is commit hash
git merge B - B is another commit hash 
#Resolve the merge conflicts
git commit 

Let "E" be the name of the resulting commit. Now we have:
 A --------------------- E
          \ /
           X
          / \
      B ---- C -- ... -- D

Step 2: Merge in the bad merge with strategy "ours"
git merge --strategy=ours C
git commit

Let "F" be the resulting commit, Now we have
A --------------------- E --  F
          \ /                /
           X    ------------
          / \ /
      B ---- C -- ... -- D

The purpose of this step is to "contain" the bad merge, so that any future "git annotate" or "git merge" that is looking backward in time will see F as a superior explanation to C of how the tree got into the current state.
The "--strategy=ours" argument means that E and F will have identical file contents, regardless of what is in C.
Note: Be very careful to specify C in this step, not anything after it (like D), because you're throwing away changes here.
Note 2: Because node F ignores changes flowing from C, after you eventually push (step 4), the redo-git-merge script will complain about it. That complaint is benign.

Step 3: Merge with trunk
Next merge in D to catch up with the latest published changes

git merge D
git commit

Let "G" be the resultant commit. Now we have a situation like this:
A --------------------- E ------ F -- G
          \ /                   /    /
           X   -----------------    /
          / \ /                    /
      B ---- C -- ... -- D --------

Step 4: Push
git push

Island hopping
When first learning to use git, many (perhaps most) developers, including myself, generally try to do merges according to what I've labeled an "island hopping" strategy, where every commit, including merge commits, compiles and passes the tests. Mechanically, what this means is that after a "git pull" or "git merge", if there are conflicts, the developer resolves the syntactic conflicts as usual. Then, before committing, the developer runs the build and tests, fixing any problems that arise. Finally, when all is well, the merge is committed.
This is appealing for two main reasons:
  1. It keeps logically related changes together. For instance, if one side of a merge renamed a function, and another side added a call using the old name, it is sensible for the merge to fix the newly added call as part of the merge.
  2. It helps with git-bisect, which learns nothing from examining commits that don't build and pass tests, wasting time and possibly leading to a less precise conclusion.
Unfortunately, this strategy can also contribute to some serious problems. But first let me describe the alternative.

Jungle warfare
The opposite strategy I call "jungle warfare": go slow, be paranoid. When doing a merge, as soon as the syntactic conflicts are resolved, you commit immediately. If you know that the resulting code won't build or pass tests, it is courteous to mention that in the commit comment. Then you try to build and test, and any resulting fixes go into a follow-on commit.
The principal advantage of this approach is that it minimizes the time and number of operations performed while the repo is in the "merge pending" state, as that state is very dangerous.
Reminder: Git_fundamentals#bash_prompt will add a notice to your shell prompt when a merge is pending. Using it is highly recommended.

